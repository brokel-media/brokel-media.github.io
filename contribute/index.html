<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Contribute</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/simplemde@1.11.2/dist/simplemde.min.css">
    <style>
        body { font-family: system-ui, sans-serif; max-width: 800px; margin: 0 auto; padding: 2rem; }
        .hidden { display: none; }
        .form-group { margin-bottom: 1rem; }
        label { display: block; margin-bottom: 0.5rem; font-weight: bold; }
        input, textarea { width: 100%; padding: 0.5rem; box-sizing: border-box; }
        button { background: #24292e; color: white; border: none; padding: 0.75rem 1.5rem; cursor: pointer; font-size: 1rem; border-radius: 4px; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        #login-screen { max-width: 400px; margin: 4rem auto; text-align: center; }
        .error { color: red; margin-top: 0.5rem; }
    </style>
</head>
<body>

    <!-- Login Screen -->
    <div id="login-screen">
        <h1>Contributor Login</h1>
        <div class="form-group">
            <input type="text" id="username-input" placeholder="GitHub Username" style="margin-bottom: 1rem;">
            <input type="password" id="password-input" placeholder="Enter the password" onkeyup="if(event.key === 'Enter') login()">
        </div>
        <button onclick="login()">Unlock</button>
        <p id="login-error" class="error"></p>
    </div>

    <!-- Editor Screen -->
    <div id="editor-screen" class="hidden">
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <h1>Manage Posts</h1>
            <button onclick="resetEditor()" style="background: #666; font-size: 0.9rem; padding: 0.5rem 1rem;">New Post</button>
        </div>

        <div id="posts-list" style="margin-bottom: 2rem; max-height: 300px; overflow-y: auto; border: 1px solid #ddd; padding: 0.5rem; border-radius: 4px;">
            <p style="color: #666; text-align: center;">Loading posts...</p>
        </div>

        <h2 id="form-title">Write a New Post</h2>
        
        <div class="form-group">
            <label>Title</label>
            <input type="text" id="post-title" placeholder="My Awesome Story">
        </div>

        <div class="form-group">
            <label>Categories (comma separated)</label>
            <input type="text" id="post-categories" placeholder="Tech, Web Development">
        </div>

        <div class="form-group">
            <label>Tags (comma separated)</label>
            <input type="text" id="post-tags" placeholder="jekyll, tutorial">
        </div>

        <div class="form-group">
            <label>Current Authors</label>
            <div id="current-authors" style="padding: 0.5rem; background: #f6f8fa; border: 1px solid #d1d5da; border-radius: 4px; min-height: 1.5rem; color: #586069;">None</div>
        </div>

        <div class="form-group">
            <label>
                <input type="checkbox" id="post-collaborative" style="width: auto;">
                Allow other authors to edit this post
            </label>
        </div>

        <div class="form-group">
            <label>Content</label>
            <div style="margin-bottom: 0.5rem;">
                <input type="file" id="image-upload" accept="image/*" style="display: none;" onchange="uploadImage()">
                <button onclick="document.getElementById('image-upload').click()" style="background: #0366d6; font-size: 0.9rem; padding: 0.5rem 1rem;">Add Image</button>
                <span id="upload-status" style="margin-left: 1rem; font-size: 0.9rem;"></span>
            </div>
            <textarea id="post-body"></textarea>
        </div>

        <button id="publish-btn" onclick="publish()">Publish Post</button>
        <p id="status-msg"></p>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/simplemde@1.11.2/dist/simplemde.min.js"></script>
    <script type="module">
        import { config } from './config.js';

        let githubToken = null;
        let simplemde = null;
        let currentSha = null;
        let currentPath = null;
        let currentDate = null;
        let currentAuthors = [];
        let loggedInAuthorName = null;
        let pendingUploads = [];

        // Repo Details
        // TODO: put these consts in a central file
        const REPO_OWNER = 'brokel-media';
        const REPO_NAME = 'brokel-media.github.io';

        window.login = async function() {
            const username = document.getElementById('username-input').value.trim();
            const password = document.getElementById('password-input').value;
            const errorMsg = document.getElementById('login-error');
            
            if (!username) {
                errorMsg.innerText = "Please enter your GitHub username.";
                return;
            }

            try {
                if (config.data.length === 0) {
                    throw new Error("Configuration not found. Please run setup.html first.");
                }

                const enc = new TextEncoder();
                const keyMaterial = await window.crypto.subtle.importKey(
                    "raw", enc.encode(password), { name: "PBKDF2" }, false, ["deriveKey"]
                );

                const key = await window.crypto.subtle.deriveKey(
                    { name: "PBKDF2", salt: new Uint8Array(config.salt), iterations: 100000, hash: "SHA-256" },
                    keyMaterial, { name: "AES-GCM", length: 256 }, true, ["decrypt"]
                );

                const decrypted = await window.crypto.subtle.decrypt(
                    { name: "AES-GCM", iv: new Uint8Array(config.iv) },
                    key,
                    new Uint8Array(config.data)
                );

                githubToken = new TextDecoder().decode(decrypted);
                
                // Validate Author
                const authorName = await validateAuthor(username);
                if (!authorName) {
                     throw new Error("GitHub username not found in authors list.");
                }
                loggedInAuthorName = authorName;

                // If successful, show editor
                document.getElementById('login-screen').classList.add('hidden');
                document.getElementById('editor-screen').classList.remove('hidden');
                
                // Init Markdown Editor
                simplemde = new SimpleMDE({ element: document.getElementById("post-body") });

                // Load posts
                loadPosts();

            } catch (e) {
                console.error(e);
                errorMsg.innerText = e.message || "Incorrect password or invalid configuration.";
            }
        };

        async function validateAuthor(username) {
             try {
                // Fetch the generated JSON file instead of the raw YAML from GitHub API
                // This works both locally (Jekyll serves it) and online (GitHub Pages serves it)
                const response = await fetch('authors.json');
                
                if (!response.ok) {
                    throw new Error(`Failed to fetch authors list: ${response.status} ${response.statusText}`);
                }
                
                const authors = await response.json();
                
                // Check if username exists as a key in the authors object
                if (authors && authors[username]) {
                    return authors[username].name;
                }
                
                return null;
             } catch (e) {
                 console.error("Error validating author:", e);
                 throw e;
             }
        }

        window.loadPosts = async function() {
            const list = document.getElementById('posts-list');
            list.innerHTML = '<p style="text-align:center">Loading...</p>';

            try {
                const response = await fetch(`https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/contents/_posts`, {
                    headers: { 'Authorization': `Bearer ${githubToken}` }
                });
                const data = await response.json();
                
                if (!Array.isArray(data)) throw new Error("Failed to load posts");

                list.innerHTML = '';
                const ul = document.createElement('ul');
                ul.style.listStyle = 'none';
                ul.style.padding = '0';

                // Sort by name (date) descending
                data.sort((a, b) => b.name.localeCompare(a.name));

                data.forEach(file => {
                    if (!file.name.endsWith('.md')) return;

                    const li = document.createElement('li');
                    li.style.padding = '0.5rem';
                    li.style.borderBottom = '1px solid #eee';
                    li.style.display = 'flex';
                    li.style.justifyContent = 'space-between';
                    li.style.alignItems = 'center';

                    const name = document.createElement('span');
                    name.innerText = file.name.replace('.md', '');
                    
                    const btn = document.createElement('button');
                    btn.innerText = 'Edit';
                    btn.style.padding = '0.25rem 0.5rem';
                    btn.style.fontSize = '0.8rem';
                    btn.onclick = () => loadPost(file.path, file.sha);

                    li.appendChild(name);
                    li.appendChild(btn);
                    ul.appendChild(li);
                });
                list.appendChild(ul);

            } catch (e) {
                list.innerHTML = `<p class="error">Error loading posts: ${e.message}</p>`;
            }
        };

        window.loadPost = async function(path, sha) {
            const status = document.getElementById('status-msg');
            status.innerText = "Loading post...";
            
            try {
                const response = await fetch(`https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/contents/${path}`, {
                    headers: { 'Authorization': `Bearer ${githubToken}` }
                });
                const data = await response.json();
                
                // Decode content
                const content = decodeURIComponent(escape(atob(data.content)));
                
                // Parse Frontmatter
                const parts = content.split('---');
                if (parts.length < 3) throw new Error("Invalid post format");
                
                const frontmatter = parts[1];
                const body = parts.slice(2).join('---').trim();

                // Extract title
                const titleMatch = frontmatter.match(/title:\s*"(.*)"/) || frontmatter.match(/title:\s*(.*)/);
                const title = titleMatch ? titleMatch[1] : "";

                // Extract categories
                const categoriesMatch = frontmatter.match(/categories:\s*\[(.*?)\]/);
                const categories = categoriesMatch ? categoriesMatch[1] : "";

                // Extract tags
                const tagsMatch = frontmatter.match(/tags:\s*\[(.*?)\]/);
                const tags = tagsMatch ? tagsMatch[1] : "";

                // Extract authors
                currentAuthors = [];
                const authorMatch = frontmatter.match(/^author:\s*(.*)$/m);
                if (authorMatch) {
                    let val = authorMatch[1].trim();
                    if (val.startsWith('[')) {
                        val = val.substring(1, val.length - 1);
                        currentAuthors = val.split(',').map(s => s.trim().replace(/^["']|["']$/g, ''));
                    } else {
                        currentAuthors = [val.replace(/^["']|["']$/g, '')];
                    }
                }

                // Extract date
                const dateMatch = frontmatter.match(/date:\s*(.*)/);
                currentDate = dateMatch ? dateMatch[1].trim() : new Date().toISOString();

                // Extract collaborative
                const collaborativeMatch = frontmatter.match(/collaborative:\s*(true|false)/);
                const isCollaborative = collaborativeMatch ? collaborativeMatch[1] === 'true' : false;

                // Set Editor
                document.getElementById('post-title').value = title;
                document.getElementById('post-categories').value = categories;
                document.getElementById('post-tags').value = tags;
                document.getElementById('current-authors').innerText = currentAuthors.join(', ') || "None";
                document.getElementById('post-collaborative').checked = isCollaborative;
                simplemde.value(body);
                
                // Set State
                currentSha = data.sha;
                currentPath = path;
                
                // Permission Check
                if (currentAuthors.length > 0 && !currentAuthors.includes(loggedInAuthorName) && !isCollaborative) {
                    document.getElementById('publish-btn').disabled = true;
                    document.getElementById('publish-btn').style.display = 'none';
                    document.getElementById('form-title').innerText = "View Post (Read Only): " + path.split('/').pop();
                } else {
                    document.getElementById('publish-btn').disabled = false;
                    document.getElementById('publish-btn').style.display = 'inline-block';
                    document.getElementById('form-title').innerText = "Edit Post: " + path.split('/').pop();
                }

                document.getElementById('publish-btn').innerText = "Update Post";
                status.innerText = "";

            } catch (e) {
                status.innerText = "Error loading post: " + e.message;
                status.style.color = "red";
            }
        };

        window.resetEditor = function() {
            document.getElementById('post-title').value = '';
            document.getElementById('post-categories').value = '';
            document.getElementById('post-tags').value = '';
            document.getElementById('current-authors').innerText = "None";
            document.getElementById('post-collaborative').checked = false;
            currentAuthors = [];
            pendingUploads = [];
            simplemde.value('');
            currentSha = null;
            currentPath = null;
            currentDate = null;
            document.getElementById('form-title').innerText = "Write a New Post";
            document.getElementById('publish-btn').innerText = "Publish Post";
            document.getElementById('status-msg').innerText = "";
        };

        window.uploadImage = async function() {
            const fileInput = document.getElementById('image-upload');
            const status = document.getElementById('upload-status');
            const file = fileInput.files[0];
            
            if (!file) return;

            status.innerText = "Processing...";
            status.style.color = "black";
            
            try {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const content = e.target.result.split(',')[1]; // Get Base64 part
                    const filename = `assets/img/uploads/${Date.now()}-${file.name.replace(/[^a-zA-Z0-9.-]/g, '_')}`;
                    
                    // Create a local URL for preview
                    const blobUrl = URL.createObjectURL(file);
                    
                    // Store for later upload
                    pendingUploads.push({
                        path: filename,
                        content: content,
                        blobUrl: blobUrl,
                        originalName: file.name
                    });

                    // Insert into editor with blob URL
                    const pos = simplemde.codemirror.getCursor();
                    simplemde.codemirror.replaceRange(`![${file.name}](${blobUrl})`, pos);
                    
                    status.innerText = "Image added (will upload on publish)";
                    status.style.color = "blue";
                    setTimeout(() => status.innerText = "", 3000);
                };
                reader.readAsDataURL(file);
            } catch (e) {
                status.innerText = "Error: " + e.message;
                status.style.color = "red";
            }
            
            // Reset input
            fileInput.value = '';
        };

        window.publish = async function() {
            const title = document.getElementById('post-title').value;
            const categories = document.getElementById('post-categories').value;
            const tags = document.getElementById('post-tags').value;
            const isCollaborative = document.getElementById('post-collaborative').checked;
            const newAuthor = loggedInAuthorName;
            let body = simplemde.value();
            const btn = document.getElementById('publish-btn');
            const status = document.getElementById('status-msg');

            if (!title || !body) {
                alert('Please fill in title and content');
                return;
            }

            if (!newAuthor) {
                alert('Error: Could not determine author name. Please log in again.');
                return;
            }

            btn.disabled = true;
            status.innerText = currentSha ? "Updating..." : "Publishing...";

            let filename = currentPath;
            let dateToUse = currentDate;

            if (!filename) {
                // Create filename slug for new post
                const date = new Date();
                dateToUse = date.toISOString();
                const dateOnly = dateToUse.split('T')[0];
                const slug = title.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '');
                filename = `_posts/${dateOnly}-${slug}.md`;
            }

            // Replace blob URLs with final paths
            if (pendingUploads.length > 0) {
                pendingUploads.forEach(img => {
                    // Replace all occurrences
                    body = body.split(img.blobUrl).join('/' + img.path);
                });
            }

            // Create Frontmatter
            let frontmatter = `---
layout: post
title: "${title.replace(/"/g, '\\"')}"
date: ${dateToUse}
`;
            if (categories && categories.trim() !== "") {
                frontmatter += `categories: [${categories}]\n`;
            }
            if (tags && tags.trim() !== "") {
                frontmatter += `tags: [${tags}]\n`;
            }

            // Handle Authors
            if (!currentAuthors.includes(newAuthor)) {
                currentAuthors.push(newAuthor);
            }
            if (currentAuthors.length > 0) {
                const authorsStr = currentAuthors.map(a => `"${a}"`).join(', ');
                frontmatter += `author: [${authorsStr}]\n`;
            }

            if (isCollaborative) {
                frontmatter += `collaborative: true\n`;
            }

            frontmatter += `---`;

            const fileContent = `${frontmatter}

${body}`;

            try {
                // If we have pending uploads, use the Git Data API for atomic commits
                if (pendingUploads.length > 0) {
                    status.innerText = "Uploading images and post...";
                    
                    // 1. Get latest commit SHA
                    const branch = 'main'; // Assuming main
                    const refRes = await fetch(`https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/git/refs/heads/${branch}`, {
                        headers: { 'Authorization': `Bearer ${githubToken}` }
                    });
                    const refData = await refRes.json();
                    const latestCommitSha = refData.object.sha;

                    // 2. Get base tree SHA
                    const commitRes = await fetch(`https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/git/commits/${latestCommitSha}`, {
                        headers: { 'Authorization': `Bearer ${githubToken}` }
                    });
                    const commitData = await commitRes.json();
                    const baseTreeSha = commitData.tree.sha;

                    // 3. Create Blobs for images and post
                    const treeItems = [];

                    // Images
                    for (const img of pendingUploads) {
                        const blobRes = await fetch(`https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/git/blobs`, {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${githubToken}`,
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                content: img.content,
                                encoding: 'base64'
                            })
                        });
                        const blobData = await blobRes.json();
                        treeItems.push({
                            path: img.path,
                            mode: '100644',
                            type: 'blob',
                            sha: blobData.sha
                        });
                    }

                    // Post Content
                    // We need to encode content to base64 to avoid encoding issues with the API
                    const contentEncoded = btoa(unescape(encodeURIComponent(fileContent)));
                    const postBlobRes = await fetch(`https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/git/blobs`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${githubToken}`,
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            content: contentEncoded,
                            encoding: 'base64'
                        })
                    });
                    const postBlobData = await postBlobRes.json();
                    treeItems.push({
                        path: filename,
                        mode: '100644',
                        type: 'blob',
                        sha: postBlobData.sha
                    });

                    // 4. Create new Tree
                    const treeRes = await fetch(`https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/git/trees`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${githubToken}`,
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            base_tree: baseTreeSha,
                            tree: treeItems
                        })
                    });
                    const treeData = await treeRes.json();

                    // 5. Create Commit
                    const commitRes2 = await fetch(`https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/git/commits`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${githubToken}`,
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            message: currentSha ? `Update post: ${title} (with images)` : `New post: ${title} (with images)`,
                            tree: treeData.sha,
                            parents: [latestCommitSha]
                        })
                    });
                    const commitData2 = await commitRes2.json();

                    // 6. Update Ref
                    const updateRes = await fetch(`https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/git/refs/heads/${branch}`, {
                        method: 'PATCH',
                        headers: {
                            'Authorization': `Bearer ${githubToken}`,
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            sha: commitData2.sha
                        })
                    });

                    if (!updateRes.ok) throw new Error("Failed to update reference");

                    // Clear pending uploads
                    pendingUploads = [];

                } else {
                    // Use simple API if no images (safer for simple edits)
                    const contentEncoded = btoa(unescape(encodeURIComponent(fileContent)));
                    const bodyPayload = {
                        message: currentSha ? `Update post: ${title}` : `New post: ${title}`,
                        content: contentEncoded
                    };

                    if (currentSha) {
                        bodyPayload.sha = currentSha;
                    }

                    const response = await fetch(`https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/contents/${filename}`, {
                        method: 'PUT',
                        headers: {
                            'Authorization': `Bearer ${githubToken}`,
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(bodyPayload)
                    });

                    if (!response.ok) {
                        const err = await response.json();
                        throw new Error(err.message);
                    }
                }

                status.innerText = currentSha ? "Success! Post updated." : "Success! Post published.";
                status.style.color = "green";
                setTimeout(() => {
                    window.location.reload();
                }, 2000);

            } catch (e) {
                status.innerText = "Error: " + e.message;
                status.style.color = "red";
                btn.disabled = false;
            }
        };
    </script>
</body>
</html>